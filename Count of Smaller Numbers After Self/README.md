#第三百一十五题
##Count of Smaller Numbers After Self
计算一个数组中，当前数i的右边有多少个数字比它小

###版本1
树状数组 （Binary Indexed Tree / Fenwick Tree）   

此题一看就是遍历的O(n^2)代码会超时，看了题目分类知道是线段树，由于一点也不懂，直接看了答案，并且学习了树状数组：
	https://.hrwhisper.me/binary-indexed-tree-fenwick-tree/
	http://blog.csdn.net/int64ago/article/details/7429868

建议参考以上两个博客弄懂树状数组是什么。

具体解法：
树状数组可以在O(logn)复杂度内统计数组中0~i，0<i<n-1内的所有数字和。那么这一题要利用这个特性，也就是需要统计数字i右边有多少个数字比它小。


那么，核心问题就是，怎么样把数字num[i]右边的比它小的数字变成树状数组从0-j，（j为i对应的某个坐标）之间的和。那么首先可以知道，0-j之间应该都是比num[i]小的数字。

解法如下：首先将num数组排序去重，得到每个数字对应的排序坐标，比如最小的数字得到的排序坐标是0,最大是n-1(无重复情况)。

然后初始化树状数组，其中0~n-1的排序坐标内都是0，（因为此时还没有统计每个坐标j内对应的数字，如果没有重复数字，那么最后肯定都是1）。

这时，我们从原数组num最右边读取数据，得到数字num[i]，找到数字num[i]对应的排序坐标j，然后统计树状数组0-j-1之间的数据之和（前面的数字都比它小，但是此时因为没有数字被加入，都是0）得到0。

然后再将它本身的排序j，加入树状数组，此时tree[j]++，下一步取倒数第二个数字，如果这个数字大于最后一个数字，那么此时对应的j_new，是大于上一个j,那么此时的统计0-j_new就得到1了。

###版本2
利用归并排序求逆序，该方法不算太难理解，可以查看http://blog.csdn.net/xyqzki/article/details/50404992   
这篇博客参考。